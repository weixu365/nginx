Index: nginx-1.13.6/src/http/modules/ngx_http_upstream_keepalive_module.c
===================================================================
--- nginx-1.13.6.orig/src/http/modules/ngx_http_upstream_keepalive_module.c
+++ nginx-1.13.6/src/http/modules/ngx_http_upstream_keepalive_module.c
@@ -12,6 +12,7 @@
 
 typedef struct {
     ngx_uint_t                         max_cached;
+    ngx_msec_t                         timeout;
 
     ngx_queue_t                        cache;
     ngx_queue_t                        free;
@@ -78,7 +79,7 @@ static char *ngx_http_upstream_keepalive
 static ngx_command_t  ngx_http_upstream_keepalive_commands[] = {
 
     { ngx_string("keepalive"),
-      NGX_HTTP_UPS_CONF|NGX_CONF_TAKE1,
+      NGX_HTTP_UPS_CONF|NGX_CONF_1MORE,
       ngx_http_upstream_keepalive,
       NGX_HTTP_SRV_CONF_OFFSET,
       0,
@@ -260,6 +261,10 @@ found:
     c->read->log = pc->log;
     c->write->log = pc->log;
     c->pool->log = pc->log;
+    
+    if (c->read->timer_set) {
+        ngx_del_timer(c->read);
+    }
 
     pc->connection = c;
     pc->cached = 1;
@@ -346,6 +351,12 @@ ngx_http_upstream_free_keepalive_peer(ng
         ngx_del_timer(c->write);
     }
 
+    if (kp->conf->timeout != NGX_CONF_UNSET_MSEC &&
+        kp->conf->timeout != 0)
+    {
+        ngx_add_timer(c->read, kp->conf->timeout);
+    }
+
     c->write->handler = ngx_http_upstream_keepalive_dummy_handler;
     c->read->handler = ngx_http_upstream_keepalive_close_handler;
 
@@ -396,6 +407,10 @@ ngx_http_upstream_keepalive_close_handle
         goto close;
     }
 
+    if (c->read->timedout) {
+        goto close;
+    }
+
     n = recv(c->fd, buf, 1, MSG_PEEK);
 
     if (n == -1 && ngx_socket_errno == NGX_EAGAIN) {
@@ -485,6 +500,8 @@ ngx_http_upstream_keepalive_create_conf(
      *     conf->max_cached = 0;
      */
 
+    conf->timeout = NGX_CONF_UNSET_MSEC;
+
     return conf;
 }
 
@@ -496,7 +513,9 @@ ngx_http_upstream_keepalive(ngx_conf_t *
     ngx_http_upstream_keepalive_srv_conf_t  *kcf = conf;
 
     ngx_int_t    n;
-    ngx_str_t   *value;
+    ngx_uint_t   i;
+    ngx_str_t   *value, s;
+    time_t       timeout;
 
     if (kcf->max_cached) {
         return "is duplicate";
@@ -517,6 +536,27 @@ ngx_http_upstream_keepalive(ngx_conf_t *
 
     kcf->max_cached = n;
 
+    for (i = 2; i < cf->args->nelts; i++) {
+
+        if (ngx_strncmp(value[i].data, "timeout=", 8) == 0) {
+
+            s.len = value[i].len - 8;
+            s.data = &value[i].data[8];
+
+            timeout = ngx_parse_time(&s, 0);
+
+            if (timeout == (time_t) NGX_ERROR) {
+                goto invalid;
+            }
+
+            kcf->timeout = timeout;
+    
+            continue;
+        }
+
+        goto invalid;
+    }
+
     uscf = ngx_http_conf_get_module_srv_conf(cf, ngx_http_upstream_module);
 
     kcf->original_init_upstream = uscf->peer.init_upstream
@@ -526,4 +566,11 @@ ngx_http_upstream_keepalive(ngx_conf_t *
     uscf->peer.init_upstream = ngx_http_upstream_init_keepalive;
 
     return NGX_CONF_OK;
+
+invalid:
+
+    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                        "invalid parameter \"%V\"", &value[i]);
+
+    return NGX_CONF_ERROR;
 }
